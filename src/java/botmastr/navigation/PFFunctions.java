package botmastr.navigation;

import botmastr.common.Common;
import botmastr.unit.UnitData;
import bwapi.TilePosition;
import bwapi.Unit;
import bwapi.UnitType;
import bwapi.WalkPosition;

import java.util.ArrayDeque;

/**
 * Helper class for the NavigationAgent. Contains methods to calculate the potentials generated by own units, enemy units
 * and neutral objects in specific points.
 * <p>
 * Author: Johan Hagelback (johan.hagelback@gmail.com)
 */
public class PFFunctions {


    /**
     * Returns the distance between two positions.
     */
    public static float getDistance(WalkPosition w1, WalkPosition w2) {
        return (float) w1.getDistance(w2);
    }

    /**
     * Returns the distance between a unit and a position.
     */
    public static float getDistance(WalkPosition wt, Unit unit) {
        final WalkPosition w2 = new WalkPosition(unit.getPosition().getX()/8, unit.getPosition().getY()/8);
        return (float) wt.getDistance(w2);
    }

    /**
     * Calculates the potential otherOwnUnit generates around unit at distance d.
     */
    public static float calcOwnUnitP(float d, WalkPosition wt, Unit unit, Unit otherOwnUnit) {
        if (unit.getID() == otherOwnUnit.getID()) {
            //Dont count collision with yourself...
            return 0;
        }

        if (otherOwnUnit.getType().isFlyer()) {
            //Cannot collide with flying units.
            return 0;
        }
        if (unit.getType().isFlyer()) {
            boolean follow = false;
            if (unit.getType().equals(UnitType.Terran_Science_Vessel) && otherOwnUnit.getType().isMechanical()) {
                follow = true;
            }
            if (unit.getType().equals(UnitType.Terran_SCV) && otherOwnUnit.getType().isMechanical()) {
                follow = true;
            }
            if (unit.getType().equals(UnitType.Protoss_Arbiter)) {
                follow = true;
            }
            if (unit.getType().equals(UnitType.Zerg_Overlord)) {
                follow = true;
            }

            if (follow) {
                //Flying support unit. Make ground units slightly
                //attractive to group up squads.
                float p = (float) (100 - d * 0.2);
                if (p < 0) {
                    p = 0F;
                }
                return p;
            } else {
                //Offensive flying unit. No collisions.
                return 0;
            }
        }

        float p = 0F;

        if ((unit.isCloaked() && !otherOwnUnit.isCloaked()) || (unit.isBurrowed() && !otherOwnUnit.isBurrowed())) {
            //Let cloaked or burrowed units stay away from visible
            //units to avoid getting killed by splash damage.
            if (d <= 4) {
                p = -50.0F;
            }
        }

        if (otherOwnUnit.isIrradiated()) {
            //Other unit under Irradite. Keep distance.
            if (d <= 2) {
                p = -50.0F;
            }
        }
        if (otherOwnUnit.isUnderStorm()) {
            //Other unit under Psionic Storm. Keep distance.
            if (d <= 3) {
                p = -50.0F;
            }
        }

        if (!unit.getType().isBuilding()) {
            if (d <= 2) {
                p = -25.0F;
            }
        }

        if (otherOwnUnit.getType().isBuilding()) {
            UnitType t = otherOwnUnit.getType();
            TilePosition ut = new TilePosition(wt.getX(), wt.getY());
            TilePosition ot = otherOwnUnit.getTilePosition();
            for (int cx = ot.getX(); cx < ot.getX() + t.tileWidth(); cx++) {
                for (int cy = ot.getY(); cy < ot.getY() + t.tileHeight(); cy++) {
                    if (ut.getX() == cx && ut.getY() == cy) {
                        p = -50F;
                    }
                }
            }
        }
        return p;
    }

    /**
     * Calculates the terrain potential in a position.
     */
    public static float getTerrainP(UnitData agent, WalkPosition wt) {
        if (agent.getUnit().getType().isFlyer()) {
            return 0;
        }
        if (!Common.getInstance().getGame().isWalkable(wt)) {
            return -1000.0f;
        }

        return 0;
    }

    /**
     * Calculates the trail potential in a position. Trails are used to reduce the local
     * optima problem when using potential fields.
     */
    public static float getTrailP(UnitData agent, WalkPosition wt) {
        if (agent.getUnit().isBeingConstructed()) {
            return 0;
        }

        float p = 0F;

        //Add current position to trail
        agent.addTrailPosition(new WalkPosition(agent.getUnit().getPosition().getX()/8, agent.getUnit().getPosition().getY()/8));

        //Get trail
        ArrayDeque<WalkPosition> trail = agent.getTrail();
        for (WalkPosition twt :
                agent.getTrail()) {
            float d = (float) twt.getDistance(wt);
            if (d <= 1.5) {
                p = -10.0F;
            }
        }

        return p;
    }

//    /**
//     * Calculates the goal potential for a defending unit.
//     */
//    public static float getGoalP(UnitData agent, WalkPosition wt) {
//        TilePosition goal = agent.getGoal();
//        if (goal.x == -1) {
//            return 0;
//        }
//
//        //Calc max wep range
//        int range = 0;
//        if (agent.getUnit().getType().isFlyer()) {
//            range = agent.getUnit().getType().airWeapon().maxRange();
//        } else {
//            range = agent.getUnit().getType().groundWeapon().maxRange();
//        }
//        if (range == 0) {
//            //Non-attacking unit. Use sight range
//            range = agent.getUnit().getType().sightRange();
//        }
//
//        //Set good defensive range
//        range = (int) (range * 0.5);
//        //if (range < 64) range = 64;
//        //Convert range to walktiles
//        range = range / 32;
//
//        float p = 0F;
//
//        WalkPosition ut = new WalkPosition(agent.getUnit().getPosition().getX(), agent.getUnit().getPosition().getY());
//        double d = ut.getDistance(wt);
//
//        if (d < range) {
//            p = (float) (100 - range * 2);
//            if (p < 0) {
//                p = 0F;
//            }
//        } else if (d >= range && d < range + 1) {
//            p = (float) 80;
//        } else {
//            float d1 = (float) (d - range);
//
//            p = (float) 80 - (float) d1;
//            if (p < 0) {
//                p = 0F;
//            }
//        }
//
//        return p;
//    }

    /**
     * Calculates the potential an offensive attacking unit generates at distance d around an enemy unit.
     */
    public static float calcOffensiveUnitP(float d, Unit attacker, Unit enemy) {
        //Check if enemy unit exists and is visible.
        if (!enemy.exists()) {
            return 0;
        }
        if (!enemy.isVisible()) {
            return 0;
        }
        if (enemy.isCloaked()) {
            return 0;
        }

        //SCV:s shall not attack
        if (attacker.getType().isWorker()) {
            return 0;
        }

        //Check for flying buildings
        if (enemy.getType().isFlyingBuilding() && enemy.isLifted()) {
            return 0;
        }

        //Check if we can attack the type
        if (enemy.getType().isFlyer() && !attacker.getType().airWeapon().targetsAir()) {
            return 0;
        }
        if (!enemy.getType().isFlyer() && !attacker.getType().groundWeapon().targetsGround()) {
            return 0;
        }

        //Calc max wep range
        int myMSD = 0;
        if (enemy.getType().isFlyer()) {
            myMSD = getAirRange(attacker) - 1;
        } else {
            myMSD = getGroundRange(attacker) - 1;
        }

        if (!attacker.getType().canAttack()) {
            //Unit cannot attack, use sightrange instead
            myMSD = 4; //attacker->getType().sightRange() / 8;
        }

        if (attacker.getType().equals(UnitType.Terran_Medic)) {
            myMSD = 6;
        }
        if (attacker.getType().equals(UnitType.Terran_SCV)) {
            myMSD = 8;
        }
        if (attacker.getType().equals(UnitType.Protoss_High_Templar)) {
            myMSD = 6;
        }
        if (attacker.getType().equals(UnitType.Zerg_Overlord)) {
            myMSD = 12;
        }

        //Calc attacker wep range
        int enemyMSD = 0;
        if (attacker.getType().isFlyer()) {
            enemyMSD = getAirRange(enemy);
        } else {
            enemyMSD = getGroundRange(enemy);
        }

        float p = 0F;

        //Enemy cannot attack back. It is safe to move
        //closer than MSD.
        if (enemyMSD == 0) {
            enemyMSD = (int) (enemyMSD * 0.5);
        }

        if (canAttack(attacker, enemy)) {
            if (d < myMSD - 1) {
                float fact = (float) 100 / myMSD;
                p = d * fact;
                if (p < 0) {
                    p = 0F;
                }
            } else if (d >= myMSD - 1 && d <= myMSD) {
                p = (float) 100;
            } else {
                float d1 = d - myMSD;

                p = (float) 80 - (float) d1;
                if (p < 0) {
                    p = 0F;
                }
            }
        }

        return p;
    }

    /**
     * Calculates the potential a defensive attacking unit generates at distance d around an enemy unit.
     */
    public static float calcDefensiveUnitP(float d, Unit attacker, Unit enemy) {
        //Check if enemy unit exists and is visible.
        if (!enemy.exists()) {
            return 0;
        }

        //Check for flying buildings
        if (enemy.getType().isFlyingBuilding() && enemy.isLifted()) {
            return 0;
        }

        //Calc attacker wep range
        int enemyMSD = 0;
        if (attacker.getType().isFlyer()) {
            enemyMSD = getAirRange(enemy) + 2;
        } else {
            enemyMSD = getGroundRange(enemy) + 2;
        }
        //Cloaked unit: Watch out for detectors.
        if (attacker.isCloaked() && enemy.getType().isDetector()) {
            enemyMSD = (int) (enemy.getType().sightRange() / 8 + 4);
        }

        double p = 0;

        //Defensive mode -> retreat
        p = (-80 + d) / 2;
        if (p > 0) {
            p = 0;
        }

        return (float) p;
    }

    /**
     * Returns true if the own unit can attack the target.
     */
    public static boolean canAttack(Unit ownUnit, Unit target) {
        UnitType oType = ownUnit.getType();
        UnitType tType = target.getType();

        if (tType.isFlyer()) {
            //Own unit is air
            if (oType.groundWeapon().targetsAir()) {
                return true;
            }
            if (oType.airWeapon().targetsAir()) {
                return true;
            }
        } else {
            //Own unit is ground
            if (oType.groundWeapon().targetsGround()) {
                return true;
            }
            if (oType.airWeapon().targetsGround()) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns the max range for the unit targeting ground.
     */
    public static int getGroundRange(Unit cUnit) {
        int range = 0;
        if (cUnit.getType().groundWeapon().targetsGround()) {
            int gwR = cUnit.getType().groundWeapon().maxRange();
            if (gwR > range) {
                range = gwR;
            }
        }
        if (cUnit.getType().airWeapon().targetsGround()) {
            int gwR = cUnit.getType().airWeapon().maxRange();
            if (gwR > range) {
                range = gwR;
            }
        }
        if (cUnit.getType().equals(UnitType.Terran_Bunker)) {
            range = UnitType.Terran_Marine.groundWeapon().maxRange();
        }

        return range / 8;
    }

    /**
     * Returns the max range for the unit targeting air.
     */
    public static int getAirRange(Unit cUnit) {
        int range = 0;
        if (cUnit.getType().groundWeapon().targetsAir()) {
            int gwR = cUnit.getType().groundWeapon().maxRange();
            if (gwR > range) {
                range = gwR;
            }
        }
        if (cUnit.getType().airWeapon().targetsAir()) {
            int gwR = cUnit.getType().airWeapon().maxRange();
            if (gwR > range) {
                range = gwR;
            }
        }
        if (cUnit.getType().equals(UnitType.Terran_Bunker)) {
            range = UnitType.Terran_Marine.groundWeapon().maxRange();
        }

        return range / 8;
    }

}
